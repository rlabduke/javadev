// (jEdit options) :folding=explicit:collapseFolds=1:
//{{{ Package, imports
package driftwood.parser;

//import java.awt.*;
//import java.awt.event.*;
import java.io.*;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.*;
//import java.util.regex.*;
//import javax.swing.*;
//import driftwood.*;
//}}}
/**
* <code>CharWindow</code> represents a Reader as a CharSequence, such that some
* window of characters is currently accessible.
* The zero-point can be advanced explictly with the advance() method;
* however, reading far enough down the sequence may make characters near the
* begining unaccessible.
* It always reports a length of Integer.MAX_VALUE. Values past the end-of-file
* are reported as the Unicode non-character U+FFFF.
*
* <p>The purpose of this class is to allow matching regular expressions
* against an input stream, for the purpose of parsing a file.
*
* <p>Any IOExceptions generated by the Reader are wrapped in RuntimeExceptions and re-thrown.
*
* <p>Copyright (C) 2007 by Ian W. Davis. All rights reserved.
* <br>Begun on Thu May  3 10:57:30 EDT 2007
*/
public class CharWindow implements CharSequence
{
//{{{ Constants
    /** The EOF signal (U+FFFF).  Not a normal Unicode character, so shouldn't normally appear in streams. */
    public static final char EOF = (char) -1;
    
    /** Kilobyte, for specifying buffer sizes */
    public static final int KILOBYTE = 1<<10;
    
    /** Megabyte, for specifying buffer sizes */
    public static final int MEGABYTE = 1<<20;
//}}}

//{{{ Variable definitions
//##############################################################################
    /** The source of characters */
    Reader  reader;
    /** How many characters have been read before the current charAt(0); can't be accessed any more. */
    long    prevChars   = 0;
    /** Number of line breaks preceding preceding charAt(0) */
    int     lineAtZero  = 0;
    /** Number of characters following the last line break but before charAt(0) */
    int     colAtZero   = 0;

    /** Lowest index (inclusive) accessible by charAt(); lower indices cause IOOBEx. */
    // just equals bufEnd - buffer.length
    /** Highest index (exclusive) accessible by charAt(); this and higher indices cause more reading. */
    int     bufEnd      = 0;
    /** Index where we hit EOF (relative to charAt()), or less than zero for none. */
    int     bufEOF      = -1;
    /** Power-of-two-minus-one bitmask used to wrap absolute character index (prevChars + charAtIndex) to a buffer index. */
    long    bufMask;
    /** Actual buffer of characters; reading and writing wrap around in a cycle. */
    char[]  buffer;
//}}}

//{{{ Constructor(s)
//##############################################################################
    /** Default buffer size is 1k, which is a little small. */
    public CharWindow(Reader reader)
    { this(reader, 1024); }
    
    public CharWindow(Reader reader, int minBufferSize)
    {
        super();
        int bufLen;
        for(bufLen = 16; bufLen < minBufferSize; bufLen <<= 1);
        this.buffer     = new char[bufLen]; // a power of two
        this.bufMask    = bufLen - 1;       // lowest N bits set
        this.reader     = reader;
    }
    
    public CharWindow(InputStream in) { this(new InputStreamReader(in)); }
    public CharWindow(InputStream in, int minBufferSize) { this(new InputStreamReader(in), minBufferSize); }
    public CharWindow(String s) { this(new StringReader(s)); }
    public CharWindow(String s, int minBufferSize) { this(new StringReader(s), minBufferSize); }
//}}}

//{{{ charAt, length, advance
//##############################################################################
    /**
    * Returns the character at relative position index, or U+FFFF if past the end-of-file.
    * Negative indices may be OK, but values before the begining of the file are undefined.
    * @throws IndexOutOfBoundsException if index is outside the valid range
    * @throws RuntimeException if there are problems reading from the stream
    */
    public char charAt(int index)
    {
        try
        {
            // Casting -1 to char gives U+FFFF, as expected.
            if(index < bufEnd - buffer.length)
                throw new IndexOutOfBoundsException("Current range is ["+(bufEnd - buffer.length)+", "+bufEnd+"); can't get "+index);
            // If we wanted to catch references before the begining of the file:
            //else if(prevChars + index < 0)
            //    throw new IndexOutOfBoundsException("Can't reference positions before the beginging of the stream");
            else while(index >= bufEnd)
            {
                int c = (char) reader.read();
                if(c == -1 && bufEOF < 0) bufEOF = bufEnd;
                buffer[ (int)((prevChars + bufEnd++) & bufMask) ] = (char) c;
            }
            return buffer[ (int)((prevChars + index) & bufMask) ];
        }
        catch(IOException ex)
        { throw new RuntimeException("IOException while trying to fill buffer", ex); }
    }
    
    /**
    * Returns Integer.MAX_VALUE until the end of stream is in sight,
    * then the actual remaining length.
    */
    public int length()
    {
        if(bufEOF < 0) return Integer.MAX_VALUE;
        else return bufEOF;
    }
    
    /** Advances the zero point of this simulated CharSequence by the specified amount. */
    public void advance(int howMuch)
    {
        if(howMuch < 0)
            throw new IllegalArgumentException("Can't advance backwards!");
        charAt(howMuch); // forces advancement
        prevChars += howMuch;
        bufEnd -= howMuch; // assert bufEnd >= 1;
        if(bufEOF >= 0) bufEOF = Math.max(0, bufEOF - howMuch);
    }
//}}}

//{{{ toString, subSequence
//##############################################################################
    /** Returns a static snapshot of the specified region */
    public String toString(int start, int end, boolean trimEOF)
    {
        StringBuffer sb = new StringBuffer(end - start);
        for(int i = start; i < end; i++)
        {
            char c = this.charAt(i);
            if(trimEOF && c == EOF) {}
            else sb.append(c);
        }
        return sb.toString();
    }
    
    /** Returns a static snapshot of the specified region without EOF characters */
    public String toString(int start, int end)
    { return toString(start, end, true); }
    
    /** Returns a static snapshot of all characters in the buffer without EOF characters */
    public String toString()
    { return toString(0, bufEnd); }
    
    /** Same as toString(start, end, false) */
    public CharSequence subSequence(int start, int end)
    { return toString(start, end, false); }
//}}}

//{{{ lineAt, columnAt
//##############################################################################
    /**
    * Returns the line number (starting from 1) of the given character index.
    * @throws IndexOutOfBoundsException if charAt(0) would
    */
    public int lineAt(int index)
    {
        int line = this.lineAtZero;
        for(int i = 0; i < index; i++)
        {
            if(charAt(i) == '\n') // line endings are normalized by Readers
                line++;
        }
        return line + 1;
    }

    /**
    * Returns the column number on the current line (starting from 1) of the given character index.
    * @throws IndexOutOfBoundsException if charAt(0) would
    */
    public int columnAt(int index)
    {
        int col = this.colAtZero;
        for(int i = 0; i < index; i++)
        {
            if(charAt(i) == '\n') // line endings are normalized by Readers
                col = 0;
            else
                col++;
        }
        return col + 1;
    }
//}}}

//{{{ main (simple unit test)
//##############################################################################
    /** Echos back complete lines typed at the console. */
    public static void main(String[] args) throws Exception
    {
        // Mac java does some weird buffering of input until Enter / ^D
        // Only ^D at begining of line followed by Enter seems to send EOF.
        CharWindow w = new CharWindow(new InputStreamReader(System.in));
        int i = 0;
        while(true)
        {
            char c = w.charAt(i++);
            if(c == w.EOF || c == '\n')
            {
                System.out.println("> "+w.subSequence(0,i-1));
                w.advance(i);
                if(c == w.EOF) break;
                else i = 0;
            }
        }
    }
//}}}

//{{{ empty_code_segment
//##############################################################################
//}}}
}//class

